# System Programming Lab 11 Multiprocessing
## Overview of implementation - Multiprocessing
  - I started by getting the functionallity of the loop for multiple images to be generated from one run of the program. I did this by starting by encassing the entire main program within a for loop, I had tried to set it up so the output file name would be updated throughout the program by adding the for loop's i into the char holding the output text. This implementation did work in looping the program and adjusting the image by the 0.90 scale factor I implemented into the code but the file name was still staying at mandel.jpg for all of the iterations. To fix this, I did some research on how to add intagers into a char and found the snprinf function so that the text would update after each iteration so that multple images would be created instead of the same one being updated slowly over a minute. I commented out the o portion of the switch case since I changed the char into a array for the snprintf function.
  - With the basis of the loop configuration being set and multiple file able to be created, I moved in to updating the code to use multiprocessing. I added the parameter of 'c' into the switch case to designated the number of processors being used in the command line of running the program. I took the while swich case portion out of the for loop and just kept the rest of the main program within it. I then added a variable "active_children" and while loop to prevent more children from being created than what was being asked of from the user in the command line. From there the fork was added and the child was set to create the image using the provided code plus a exit(0) line to close the child and the parent was set to resize the scale of the the image using the 0.90 scale factor on the x scale since the why scale was based off of the x scale and tracked that a new child was created. Finally there is a while loop to wait for any remaining children still active before ending the program.
## Overview of implementation - Multithreading
  - Using the multiprocessing code, I first added the defined variable of MAX_THREADS to be the required 20 threads, added 't' to the switch case statement along with the variable num_threads to add the use of threads into the command line. I then went back and created the struct thread_data_t that shared the data for all the threads and held the pixel start and end locations for the next thread to use. I then created a helper method named compute_image_thread which computes the portion of the image for each thread that it is designated. From there I added in multithreading in the compute_image function by doing a if statement to use the old code if there was only one thread, and use the use the multithreading update whcih consisited of creating arrays of threads and thread_data_t structs and calculating the number per thread and any left over rows, then a for loop for each thread to initialize and generate its portion of the image and any extra rows that were left over. Then the thread was crated and used the compute_image_thread helper function and then waited for all threads to complete and joined back together. Since this was just implemented into the compute_image function the multiprocessing portion of the code did not need to be updated and all functionallity was kept from Lab 11.
## Runtime Results Graph - Multiprocessing
<img width="2412" height="1667" alt="Picture1" src="https://github.com/user-attachments/assets/1f587859-de7b-4ec8-8b73-5832498cdc72" />

  - This graph shows the time for each program to finish at various image amounts since I created the video with more than 50 images for smoothness.
## Runtime Results Graph and Table - Multithreading
<img width="2395" height="1359" alt="Picture2" src="https://github.com/user-attachments/assets/8607190b-1fcf-4616-9be0-52bbea8bc4e7" />

|    Time   | 1 Thread | 2 Threads | 5 Threads | 10 Threads| 20 Threads |
|-----------|----------|-----------|-----------|-----------|------------|
| 1 Process | 112.427s | 81.387s   | 45.590s   | 33.906s   | 26.427s    |
| 2 Process | 51.961s  | 45.659s   | 32.546s   | 25.833s   | 23.342s    |
| 5 Process | 40.159s  | 35.003s   | 24.030s   | 23.741s   | 25.579s    |
| 10 Process| 25.996s  | 24.445s   | 24.394s   | 24.056s   | 24.617s    |
| 20 Process| 23.758s  | 23.571s   | 23.808s   | 24.250s   | 23.829s    |

  - This graph and table show the relationship between the number of processes and threads.
## Results - Multiprocessing
  As expected, as there were more processors being used the time for the program to finished, but there was a very distinct trend for all of the different numbers of images being processed. The trend between all of the test was that the time for 20 processes was roughly 1/6 of the time for 1 process for all of the image amounts. Also the amount of time change between each of the test followed a similar pattern except for the 250, whcih makes sense since it finished by rendering only the color yellow, not being too instense to render compared to previous frames. For the most cases, the time was usally 2 times longer for the next amount of generated images. Also in terms of efficiency per process, the difference between 10 and 20 was mostly negligible for the amount of added processes, and only became relievent when generating more than 200 images, so overall the best number of processes tested for this computer (Lenovo Thinkpad X1 Yoga Gen 8) was 10 processes for efficent use, which makes sense since this a 12 core laptop.
## Results - Multithreading
  When it came to runtime, it was kind of like a topigraphical map for the use of multithrading and multiprocessing. 1:1 was the high point and 20:20 was the theorectical low point and time for the most part was linear between those points. When using a lower number of processors (ie. 1 or 2) there was a noticable decrease in the amount of time needed, but at the same time with lower threads, there was the most noticable changes between processes at 1 and 2 threads, and then became less dramatic of changes. Overall more processes was overall the most impactfull on time causing the largest jumps between intervals and the lowest time being procduced at 2:20, closer to the max amount of processor over threads. I think this time impact between processes and threads is partcially due the CPU being used in these computers since overall the times are close to each other with the multiprocessing being only sighlty faster. Since these are 12 core CPUs @ roughly 1.30GHz, they are good at multicore (multiprocess) tasks but weak with multithread task since it is running at a slowwer speed. If you where to replicate these test on computer with a 8 core CPU @ roughly 3.8Ghz, you would probably find that the times would be switched or even that the multithreading times would be noticably better than the multiprocessing. For this computer the sweet spot seemed to be at either 20 processes and 2 threads or at 2 processes and 20 threads with those being the lowest recored times.
  
<img width="1985" height="1530" alt="Picture3" src="https://github.com/user-attachments/assets/996c51f1-6650-4bd0-968d-f22c60924564" />
