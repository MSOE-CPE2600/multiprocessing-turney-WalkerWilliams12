# System Programming Lab 11 Multiprocessing
## Overview of implementation
  - I started by getting the functionallity of the loop for multiple images to be generated from one run of the program. I did this by starting by encassing the entire main program within a for loop, I had tried to set it up so the output file name would be updated throughout the program by adding the for loop's i into the char holding the output text. This implementation did work in looping the program and adjusting the image by the 0.90 scale factor I implemented into the code but the file name was still staying at mandel.jpg for all of the iterations. To fix this, I did some research on how to add intagers into a char and found the snprinf function so that the text would update after each iteration so that multple images would be created instead of the same one being updated slowly over a minute. I commented out the o portion of the switch case since I changed the char into a array for the snprintf function.
  - With the basis of the loop configuration being set and multiple file able to be created, I moved in to updating the code to use multiprocessing. I added the parameter of 'c' into the switch case to designated the number of processors being used in the command line of running the program. I took the while swich case portion out of the for loop and just kept the rest of the main program within it. I then added a variable "active_children" and while loop to prevent more children from being created than what was being asked of from the user in the command line. From there the fork was added and the child was set to create the image using the provided code plus a exit(0) line to close the child and the parent was set to resize the scale of the the image using the 0.90 scale factor on the x scale since the why scale was based off of the x scale and tracked that a new child was created. Finally there is a while loop to wait for any remaining children still active before ending the program.
## Runtime Results Graph
<img width="2412" height="1667" alt="Picture1" src="https://github.com/user-attachments/assets/1f587859-de7b-4ec8-8b73-5832498cdc72" />

  - This graph shows the time for each program to finish at various image amounts since I created the video with more than 50 images for smoothness.
## Results
  As expected, as there were more processors being used the time for the program to finished, but there was a very distinct trend for all of the different numbers of images being processed. The trend between all of the test was that the time for 20 processes was roughly 1/6 of the time for 1 process for all of the image amounts. Also the amount of time change between each of the test followed a similar pattern except for the 250, whcih makes sense since it finished by rendering only the color yellow, not being too instense to render compared to previous frames. For the most cases, the time was usally 2 times longer for the next amount of generated images. Also in terms of efficiency per process, the difference between 10 and 20 was mostly negligible for the amount of added processes, and only became relievent when generating more than 200 images, so overall the best number of processes tested for this computer (Lenovo Thinkpad X1 Yoga Gen 8) was 10 processes for efficent use, which makes sense since this a 12 core laptop.
